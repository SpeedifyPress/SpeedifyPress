<?php
/**
 * Advanced Cache for SpeedifyPress
 *
 * This file is auto‑generated by the SpeedifyPress plugin on activation.
 * It is placed in the wp‑content directory and is loaded very early by WordPress
 * to serve cached pages.
 *
 * Configuration placeholders (to be replaced during activation):
 *   SPRESS_SEPARATE_COOKIE_CACHE
 *   SPRESS_CACHE_LOGGED_IN_USERS
 *   SPRESS_CACHE_MOBILE_SEPARATELY
 *   SPRESS_IGNORE_QUERYSTRINGS
 *   SPRESS_CACHE_LIFETIME
 *
 * @package SpeedifyPress
 */

namespace SPRESS;
use SPRESS\Speed\Cache;
use SPRESS\Speed;

// Prevent direct access.
if ( ! defined( 'ABSPATH' ) ) {
    exit;
}

if ( ! defined( 'SPRESS_MULTISITE_IDENTIFIER' ) ) {
    define( 'SPRESS_MULTISITE_IDENTIFIER', '%%SPRESS_MULTISITE_IDENTIFIER%%' );
}
if ( ! defined( 'SPRESS_SEPARATE_COOKIE_CACHE' ) ) {
    define( 'SPRESS_SEPARATE_COOKIE_CACHE', '%%SPRESS_SEPARATE_COOKIE_CACHE%%' );
}
if ( ! defined( 'SPRESS_CSRF_EXPIRY_SECONDS' ) ) {
    define( 'SPRESS_CSRF_EXPIRY_SECONDS', '%%SPRESS_CSRF_EXPIRY_SECONDS%%' );
}
if ( ! defined( 'SPRESS_FORCE_GZIPPED_OUTPUT' ) ) {
    define( 'SPRESS_FORCE_GZIPPED_OUTPUT', '%%SPRESS_FORCE_GZIPPED_OUTPUT%%' );
}
if ( ! defined( 'SPRESS_CACHE_PATH_UPLOADS' ) ) {
    define( 'SPRESS_CACHE_PATH_UPLOADS', '%%SPRESS_CACHE_PATH_UPLOADS%%' );
}
if ( ! defined( 'SPRESS_CACHE_LOGGED_IN_USERS' ) ) {
    define( 'SPRESS_CACHE_LOGGED_IN_USERS', '%%SPRESS_CACHE_LOGGED_IN_USERS%%' );
}
if ( ! defined( 'SPRESS_CACHE_MOBILE_SEPARATELY' ) ) {
    define( 'SPRESS_CACHE_MOBILE_SEPARATELY', '%%SPRESS_CACHE_MOBILE_SEPARATELY%%' );
}
if ( ! defined( 'SPRESS_IGNORE_QUERYSTRINGS' ) ) {
    define( 'SPRESS_IGNORE_QUERYSTRINGS', '%%SPRESS_IGNORE_QUERYSTRINGS%%' );
}
if ( ! defined( 'SPRESS_CACHE_LIFETIME' ) ) {
    define( 'SPRESS_CACHE_LIFETIME', '%%SPRESS_CACHE_LIFETIME%%' );
}
if ( ! defined( 'SPRESS_DIR_NAME' ) ) {
    define( 'SPRESS_DIR_NAME', '%%SPRESS_DIR_NAME%%' );
}
if ( ! defined( 'SPRESS_PLUGIN_MODE' ) ) {
    define( 'SPRESS_PLUGIN_MODE', '%%SPRESS_PLUGIN_MODE%%' );
}
if ( ! defined( 'SPRESS_DISABLE_URLS' ) ) {
    define( 'SPRESS_DISABLE_URLS', '%%SPRESS_DISABLE_URLS%%' );
}
if ( ! defined( 'SPRESS_PRELOAD_FONTS_DESKTOP_ONLY' ) ) {
    define( 'SPRESS_PRELOAD_FONTS_DESKTOP_ONLY', '%%SPRESS_PRELOAD_FONTS_DESKTOP_ONLY%%' );
}

//Require our SPRESS classes
$file = __DIR__ . "/plugins/" . SPRESS_DIR_NAME . "/vendor/autoload.php";
if (!file_exists($file)) {
    return;
}

require_once $file;

/**
 * Class AdvancedCache
 *
 * Encapsulates SpeedifyPress advanced caching logic.
 */
class AdvancedCache {

    public static $multisite_identifier;
    public static $separate_cookie_cache;
    public static $cache_logged_in_users;
    public static $cache_mobile_separately;
    public static $ignore_querystrings;
    public static $cache_lifetime;
    public static $original_uri;
    public static $plugin_mode;
    public static $disable_urls;
    public static $preload_fonts_desktop_only;

    /**
     * Initialize configuration from defined constants.
     */
    public static function init() {
        
        self::$multisite_identifier       = SPRESS_MULTISITE_IDENTIFIER;
        self::$separate_cookie_cache      = SPRESS_SEPARATE_COOKIE_CACHE;
        self::$cache_logged_in_users      = SPRESS_CACHE_LOGGED_IN_USERS;
        self::$cache_mobile_separately    = SPRESS_CACHE_MOBILE_SEPARATELY;
        self::$ignore_querystrings        = SPRESS_IGNORE_QUERYSTRINGS;
        self::$cache_lifetime             = intval(SPRESS_CACHE_LIFETIME);
        self::$original_uri               = Speed::get_sanitized_uri($_SERVER['REQUEST_URI']);
        self::$plugin_mode                = SPRESS_PLUGIN_MODE;
        self::$disable_urls               = SPRESS_DISABLE_URLS;
        self::$preload_fonts_desktop_only = SPRESS_PRELOAD_FONTS_DESKTOP_ONLY;

    }

    /**
     * Check early-exit conditions.
     *
     * @return bool True if any condition requires exiting.
     */
    protected static function should_exit() {
        //Check if disabled
        if(self::$plugin_mode === "disabled") {
            return true;
        } else if(self::$plugin_mode === "partial") {
            //Check partial URLs
            $partial_urls = array_filter( array_map('trim', explode("\n", self::$disable_urls)) );
            foreach ( $partial_urls as $partial ) {
                // treat it as a literal substring
                $needle = preg_quote( $partial, '/' );
                if ( preg_match( "/{$needle}/", self::$original_uri ) ) {
                    return true;
                }
            }    
        }
        // Exit if WP-CLI is running.
        if ( defined('WP_CLI') && WP_CLI ) {
            return true;
        }
        // Process only GET and HEAD requests.
        if ( !isset($_SERVER['REQUEST_METHOD']) || !in_array($_SERVER['REQUEST_METHOD'], ['GET','HEAD']) ) {
            return true;
        }

        // Check for a cache bust parameter 
        if ( isset($_GET['speedify_cache_bust']) ) {
            return true;
        }
        // Check for a 200 response code, if available.
        if ( function_exists('http_response_code') && http_response_code() !== 200 ) {
            return true;
        }
        // Exit if REST or XMLRPC requests are defined.
        if ((defined('REST_REQUEST') && REST_REQUEST) || (defined('XMLRPC_REQUEST') && XMLRPC_REQUEST)) {
            return true;
        }
        // Disallow caching for specific files/directories.
        $disallowed = ['wp-cron.php', 'xmlrpc.php', 'wp-login.php', 'wp-admin'];
        $request_uri = isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : '';
        foreach ($disallowed as $file) {
            if (stripos($request_uri, $file) !== false) {
                return true;
            }
        }
        // Disallow caching for REST API requests (wp-json).
        if (stripos($request_uri, '/wp-json') !== false) {
            return true;
        }        
        // Additionally, disallow if the URL path ends with disallowed extensions.
        $path = parse_url($request_uri, PHP_URL_PATH);
        if ($path) {
            $exts = ['.ico', '.txt', '.xml', '.xsl'];
            foreach ($exts as $ext) {
                if (substr($path, -strlen($ext)) === $ext) {
                    return true;
                }
            }
        }
        // Do not serve cache during cron.
        if (defined('DOING_CRON') && DOING_CRON) {
            return true;
        }
        // Exit for AMP pages.
        if (stripos($request_uri, '/amp') !== false || isset($_GET['amp'])) {
            return true;
        }
        // If caching for logged-in users is disabled, exit if any cookie key starts with "wordpress_logged_in".
        if (self::$cache_logged_in_users !== 'true') {
            foreach ($_COOKIE as $key => $value) {
                if (strpos($key, 'wordpress_logged_in') === 0) {
                    return true;
                }
            }
        }
        return false;
    }



    /**
     * Checks if the given cache file is expired based on the configured cache lifetime.
     * A lifetime of 0 means the cache never expires.
     *
     * @param string $cache_file The path to the cache file.
     * @return bool True if expired; false otherwise.
     */
    public static function is_cache_expired($cache_file) {
        if (intval(self::$cache_lifetime) === 0) {
            return false;
        }
        if (!file_exists($cache_file)) {
            return true;
        }
        $expiry_time = time() - (intval(self::$cache_lifetime) * 3600);
        return (filemtime($cache_file) < $expiry_time);
    }    

    /**
     * Attempt to serve the cached file.
     *
     * If a valid cache file exists, this method sends appropriate headers
     * (including handling 304 Not Modified and setting extra CDN/cache headers)
     * and outputs the content using readfile() for efficiency.
     *
     * @param string $cache_file The full path to the cache file.
     * @return void
     */
    protected static function serve_cache_file($cache_file) {
        if (file_exists($cache_file)) {

            // If the file is expired, delete it and its gzipped version.
            if (self::is_cache_expired($cache_file)) {
                unlink($cache_file);
                if (file_exists($cache_file . '.gz')) {
                    unlink($cache_file . '.gz');
                }
                return; //just proceed to standard content
            }

            $last_modified = filemtime($cache_file);

            // Set extra headers if not already sent.
            if (!headers_sent()) {

                $cacheable = true;
                // If an external update is required, do NOT advertise HIT and do NOT allow CDN caching
                $cache_file_base = dirname($cache_file);
                $check_file = $cache_file_base . "/update_required";
                if (file_exists($check_file)) {
                    unlink($check_file);
                    $cacheable = false;
                }

                if ($cacheable) {
                    header('x-spdy-cache: HIT');
                    header('x-spdy-source: PHP');

                    // Shared-cache (CDN) may store for 30 days; browsers revalidate every time.
                    header('Cache-Control: public, max-age=0, s-maxage=2592000, stale-while-revalidate=300, stale-if-error=86400');                
                    header('CDN-Cache-Control: max-age=2592000');

                } else {
                    // Serve the local file, but prevent CF from storing it (soft "lazy purge" case)
                    header('x-spdy-source: PHP');
                    header('Cache-Control: private, no-store, max-age=0');
                    header('Pragma: no-cache');
                    header('Expires: 0');
                }

                $host = isset($_SERVER['HTTP_HOST']) ? preg_replace('/[^A-Za-z0-9\.\-]/', '', $_SERVER['HTTP_HOST']) : '';
                header("Cache-Tag: $host"); 
            }


            if (isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {
                $if_modified_since = strtotime($_SERVER['HTTP_IF_MODIFIED_SINCE']);
                if ($if_modified_since >= $last_modified) {
                    header($_SERVER['SERVER_PROTOCOL'] . ' 304 Not Modified', true, 304);
                    exit;
                }
            }

            // Determine if the cache file is gzipped.
            $isGz = (substr($cache_file, -3) === '.gz');

            // Read the file content (decompress if gzipped).
            if ($isGz) {
                $raw_content = file_get_contents($cache_file);
                $content = gzdecode($raw_content);
            } else {
                $content = file_get_contents($cache_file);
            }

            // Check if we need to strip font preload sections.
            $shouldStrip = false;
            if (self::$preload_fonts_desktop_only === 'true') {
                $user_agent = isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '';
                if (preg_match('/Mobile|Android|Silk\/|Kindle|BlackBerry|Opera (Mini|Mobi)/i', $user_agent)) {
                    $shouldStrip = true;
                }
            }
            if ($shouldStrip) {
                // Strip anything between <!-- FontPreload --> and <!-- /FontPreload -->
                $content = preg_replace('/<!--\s*FontPreload\s*-->.*?<!--\s*\/FontPreload\s*-->/is', '', $content);
            }

            $elapsed_time = number_format(microtime(true) - $GLOBALS['start_time'],10);
            //$content .= "<!--E: $elapsed_time -->\n";

            // Set basic headers.
            header('Content-Type: text/html; charset=utf-8');
            header('Last-Modified: ' . gmdate('D, d M Y H:i:s', $last_modified) . ' GMT');

            // If originally gzipped
            if (SPRESS_FORCE_GZIPPED_OUTPUT === 'true') {
                ini_set('zlib.output_compression', '0');
                $gz = gzencode($content, 6, ZLIB_ENCODING_GZIP);
                header('Content-Encoding: gzip');
                header('Content-Length: ' . strlen($gz)); 
                header('Vary: Accept-Encoding');
                header('x-spdy-gz: 1'); 
                echo $gz;
            } else {
                echo $content;
            }
            exit;

        }
    }    


    /**
     * Serves the CSRF token as a JSON response.
     *
     * This function is only invoked if the original URI is '/_csrf'. It generates
     * a CSRF token using SPEED::generate_csrf_token() and serves it as a JSON
     * response with Content-Type 'application/json' and Cache-Control 'no-store,
     * no-cache, must-revalidate, max-age=0'. The response is also marked with
     * the 'Pragma: no-cache' header.
     *
     * @return void
     */
    public static function serve_csrf_token() {

        $path = parse_url($_SERVER['REQUEST_URI'] ?? '/', PHP_URL_PATH);        
        if ($path === '/_csrf') {

            // Ensure a binding exists BEFORE generating the token
            if (empty($_COOKIE['spdy_guest'])) {
                Cache::generate_guest_cookie();
            }            

            $page_url = isset($_SERVER['HTTP_X_PAGE_URL']) ? $_SERVER['HTTP_X_PAGE_URL'] : SPEED::get_url();
            $csrf_token = Speed::generate_csrf_token($page_url);

            header('X-CSRF-Token: ' . $csrf_token);
            header('X-Content-Type-Options: nosniff');
            header_remove('ETag');
            header_remove('Last-Modified');            
            header('Cache-Control: no-store, no-cache, must-revalidate, max-age=0');
            header('Pragma: no-cache');
            header('Content-Type: text/plain; charset=utf-8');

            // For HEAD, no body needed
            http_response_code(204); // No Content

            exit;

        }

    }


    /**
     * Main serve method that ties all subroutines together.
     *
     * @return void
     */
    public static function serve() {

        //Token endpoint
        self::serve_csrf_token();        

        $GLOBALS['start_time'] = microtime(true);

        self::init();
        if (self::should_exit()) {
            return;
        }

        //Get full URL
        $full_url  = Speed::get_clean_url(null,self::$ignore_querystrings);

        //Not running Speed::init, so set hostname here
        Speed::$hostname = parse_url($full_url, PHP_URL_HOST);

        //Get the cache file
        $file_type = "";
        if( SPRESS_FORCE_GZIPPED_OUTPUT === 'true' ) {
            $file_type = "gz";
        } else {
            $file_type = "html";
        }
        $cache_file = Cache::get_cache_filepath($full_url, $file_type, self::$separate_cookie_cache, self::$cache_logged_in_users, self::$cache_mobile_separately);

        //Serve the cache file, will exit if exists
        self::serve_cache_file($cache_file);

        // Not serving a cached file so mark this response non-cacheable at CDN
        if (!headers_sent()) {
            header('Cache-Control: private, no-store, max-age=0');
            header('Pragma: no-cache');
            header('Expires: 0');
        }

    }
}

// Immediately run the AdvancedCache.
AdvancedCache::serve();
